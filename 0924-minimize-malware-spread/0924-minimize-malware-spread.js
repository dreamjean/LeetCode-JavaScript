/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
  const n = graph.length;
  const area = new Array(n).fill(0);
  const malCount = new Array(n).fill(0);
  const uf = new UnionFind(n);
  let [save, ans] = [0, Math.min(...initial)];
  
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (graph[i][j]) uf.union(i, j);
    }
  }
  
  for (let i = 0; i < n; i++) area[uf.find(i)]++;
  initial.forEach((num) => malCount[uf.find(num)]++);
  
  for (let num of initial) {
    const index = uf.find(num);
    if (malCount[index] === 1) {
      let areaNum = area[index];
      if (areaNum > save) {
        save = areaNum;
        ans = num;
      }
      else if (areaNum === save) ans = Math.min(ans, num);
    }
  }
  
  return ans;
};

class UnionFind {
  constructor(n) {
    this.parent = Array.from({ length: n }, (_, i) => i);
  }
  
  find(x) {
    if (x !== this.parent[x]) this.parent[x] = this.find(this.parent[x]);
    
    return this.parent[x];
  }
  
  union(x, y) {
    let rootX = this.find(x);
    let rootY = this.find(y);
    if (rootX !== rootY) this.parent[rootX] = rootY; 
  }
}
