class UnionFind:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.size = [1] * n
        
    def find(self, x):
        if x != self.parent[x]:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
      
    def union(self, x, y):
        rootX, rootY = self.find(x), self.find(y)
        if rootX == rootY:
            return
        if self.size[rootX] < self.size[rootY]:
            self.parent[rootX] = rootY
            self.size[rootY] += self.size[rootX]
        else:
            self.parent[rootY] = rootX
            self.size[rootX] += self.size[rootY]
        
        
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        uf = UnionFind(n)
        clean = list(set(range(n)) - set(initial))
        infectNode = defaultdict(set)
        infectedCount = Counter()
        maxCount, ans = 0, min(initial)
        
        for u, v in itertools.combinations(clean, 2):
            if graph[u][v]:
                uf.union(u, v)
                
        for u in initial:
            for v in clean:
                if graph[u][v]:
                    infectNode[u].add(uf.find(v))
            for i in infectNode[u]:
                infectedCount[i] += 1
                
        for i, nodes in infectNode.items():
            count = 0
            for node in nodes:
                if infectedCount[node] == 1:
                    count += uf.size[node]
                if count > maxCount or (count == maxCount and i < ans):
                    maxCount = count
                    ans = i
        return ans
        
        